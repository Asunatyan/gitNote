## 可见性

一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。



- 单核
  - 

![a07e8182819e2b260ce85b2167d446da](https://static001.geekbang.org/resource/image/a0/da/a07e8182819e2b260ce85b2167d446da.png)

- 多核
  - 比如两个线程执行1000次V+=1
  - 将内存的变量V 读到各自的 CPU 缓存里
  - 各自的 CPU 缓存里都有了 V 的值，两个线程都是基于 CPU 缓存里的 V 值来计算
  - 计算完成之后把自身的cup缓存值覆盖变量V
  - 两个线程的时差越大就越准

![e2aa76928b2bc135e08e7590ca36e0ea](https://static001.geekbang.org/resource/image/e2/ea/e2aa76928b2bc135e08e7590ca36e0ea.png)

## 原子性

ount += 1至少需要三条 CPU 指令。

- 首先，需要把变量 count 从内存加载到 CPU 的寄存器；
- 之后，在寄存器中执行 +1 操作；
- 最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。



指令执行的过程中被别的指令插进来了

![33777c468872cb9a99b3cdc1ff597063](https://static001.geekbang.org/resource/image/33/63/33777c468872cb9a99b3cdc1ff597063.png)

## 有序性

 new xxxxx()

- 分配一块内存 M；
- 在内存 M 上初始化 Singleton 对象；
- 然后 M 的地址赋值给 instance 变量。

但是实际上优化后的执行路径却是这样的

- 分配一块内存 M；
- 将 M 的地址赋值给 instance 变量；
- 最后在内存 M 上初始化 Singleton 对象。

