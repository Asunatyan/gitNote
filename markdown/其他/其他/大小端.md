## 大小端

 计算机的字节顺序模式分为大端数据模式和小端数据模式，它们是根据数据在内存中的存储方式来区分的。

- 小端字节顺序的数据存储模式是按内存增大的方向存储的，即低位在前高位在后；
  - `0xabcd`中的`0xcd`属于低位数据，故存在Bit[0,7]，`0xab`属于高位数据，故存储在Bit[8,15]；
- 大端字节顺序的数据存储方向恰恰是相反的，即高位在前，低位在后
  - 大端, 高位数据`0xab`存储在低位Bit[0,7]，低位数据`0xcdb`存储在高位Bit[8,15]。



高低位:按照位数的高低来区分,比如百分位低于千分位(千百十个)



![img](https://img-blog.csdn.net/20180610144800458)

也就是两个两个字节的倒过来排序



![1635908604674](C:\Users\dingqiaokun\AppData\Roaming\Typora\typora-user-images\1635908604674.png)



```java
public static String bytesToLittleEndianHexString(byte[] bytes, int size) {
       //0x,ab,cd,14  -> 0x,14,cd,ab 两个16进制数正好对应一个字节,也就是反转字符串就变成小端模式
        ArrayUtils.reverse(bytes);
        int i = size - bytes.length;
        StringBuilder stringBuilder = new StringBuilder(bytesToHex(bytes));
        if (i<0) {
            stringBuilder.substring(0,size * 2);
        }else if (i>0){
            for (int j = 0; j < i; j++) {
                stringBuilder.append( "00");
            }
        }
        return stringBuilder.toString();
    }
```

```java
public static byte[] stringXor(String string2, String string1) {
        String subString = "";
        if (string2.length() > string1.length()) {
            subString = string2.substring(string2.length() - string1.length() - 1, string2.length());
        } else if (string2.length() != string1.length()) {
            subString = string1.substring(string1.length() - string2.length() - 1, string1.length());
        }
        byte[] secretkeyBytes = string2.getBytes(StandardCharsets.UTF_8);
        byte[] macBytes = string1.getBytes(StandardCharsets.UTF_8);

        int min = Math.min(secretkeyBytes.length, macBytes.length);
        ByteBuffer buffer = ByteBuffer.allocate(Math.max(secretkeyBytes.length, macBytes.length));
        for (int i = 0; i < min; i++) {
            int data = macBytes[i] ^ secretkeyBytes[i];
            buffer.put((byte) data);
        }
        buffer.put(subString.getBytes(StandardCharsets.UTF_8));

        return buffer.array();
    }

    public static byte[] stringXorToLittleEndianHexString(String string2, String string1) {
        byte[] secretkeyBytes = string2.getBytes(StandardCharsets.UTF_8);
        byte[] macBytes = string1.getBytes(StandardCharsets.UTF_8);

        int max = Math.max(secretkeyBytes.length, macBytes.length);
        ByteBuffer buffer = ByteBuffer.allocate(max);
        for (int i = 0; i < max; i++) {
            int data;
            if (secretkeyBytes.length - i > 0 && macBytes.length - i > 0) {
                data = macBytes[i] ^ secretkeyBytes[i];
            } else {
                if (secretkeyBytes.length - i > 0) {
                    data = secretkeyBytes[i];
                }else {
                    data = macBytes[i];
                }
            }
            buffer.put((byte) data);
        }
        return buffer.array();
    }
```

